# web性能

## 1.导致web性能问题的两个原因

* 网络延迟
* 大部分情况下的浏览器单线程执行（关键）

确保主线程能够完成交给它的所有工作，始终能处理用户交互

尽可能和适当地减少主线程地责任 == 提高网页性能



## 2.导航

加载web页面地第一步



### 1.DNS查询

**导航的第一步是区寻找页面资源的位置**

#### 1.1.用户请求

输入一个url

#### 1.2.检查本地缓存是否发送DNS查询请求

1.检查本地DNS缓存，如果缓存中没有，浏览器就会向本地DNS解析器发送一个查询请求（通常是ISP提供）

2.浏览器向域名服务器发起DNS查询请求，根 => 顶级域 => 权威 => 获取ip

3.DNS解析器得到一个ip地址返回给服务器（ip地址会被缓存一段时间）

4.对目标服务器发送http请求，加载网站内容



* 每个主机名在加载页面通常只需要进行一次DNS查询，对于页面指向不同的主机名则需要多次DNS查询



### 2.TCP握手

浏览器获取到服务器ip地址，会通过**三次握手**与服务器建立连接，在浏览器和服务器通过上层协议https发送数据之前，可以协商网络TCP套接字连接的一些参数

1.通过TCP首先发送了三个消息进行协商，然后在两台电脑之间开始一个TCP会话

2.当请求尚未发出的时候，终端和每台服务器之间还要来回多发送三条消息



### 3.TLS协商

对于https建立的安全连接，还需要另外一次握手 == TLS协商

用来决定使用哪种密码对通信进行加密，验证服务器，在开始实际数据传输前建立安全连接

这需要在实际发送内容请求之前，再往返服务器5次



**如此经过 8 次往返，浏览器终于可以发出请求**



## 3.响应

浏览器和web服务器建立了连接，浏览器会代表用户发送一个初始的http的get请求

请求文件通常是一个html文件，服务器收到请求使用相关的响应头和html内容进行回复



### 3.1.拥塞控制 / TCP慢启动

在传输过程中，TCP包被分割成段，由于TCP保证了数据包的顺序，所以服务器在发送一定数量的分段后，必须从客户端接收一个ACK包的确认

如果服务器在发送每个分段之后都等待 ACK，那么客户端将频繁地发送 ACK，并且可能会增加传输时间，即使在网络负载较低的情况下也是如此

另一方面，一次发送过多的分段会导致在繁忙的网络中客户端无法接收分段并且长时间地只会持续发送 ACK，服务器必须不断重新发送分段的问题



平衡传输分段的数量 == TCP慢启动算法，用于逐渐增加传输数据量，直到确定最大网络带宽，在网络负载较高时减少数据传输数据量

传输段的数量由拥塞窗口(CWND)值来控制，该值是发送的字节数，客户端收到后必须发送ACK，收到ACK则CWND翻倍，否则减半。通过这个机制在发送多少取得平衡





## 4.解析

浏览器收到第一个数据分块，就可以开始解析收到的信息

解析 == 浏览器将通过网络接收的数据转换成DOM和CSSOM的步骤，通过渲染器在屏幕上将它们绘制成页面

前14kb中包含浏览器开始渲染页面所需的所有内容（或者至少包含页面模板，第一次渲染所需的CSS和HTML ）



### 4.1.构建DOM树

处理html标记并构造DOM树，html解析涉及到符号化和树的构造

### 4.2.预加载扫描器

浏览器构建 DOM 树时，这个过程占用了主线程。同时，*预加载扫描器*会解析可用的内容并请求高优先级的资源，如 CSS、JavaScript 和 web 字体。

我们不必等到解析器找到对外部资源的引用时才去请求。它将在后台检索资源，而当主 HTML 解析器解析到要请求的资源时，它们可能已经下载中了，或者已经被下载。预加载扫描器提供的优化减少了阻塞

**等待获取CSS不会阻塞HTML的解析或者下载，但是会阻塞JS，**因为JS经常用于查询元素的CSS属性

### 4.3.构建CSSOM树

第二步是处理CSS并构建CSSOM树，和DOM是相似的，但是是两棵树，独立的数据结构

速度 == 一字快



**DOM树和CSSOM树结合为渲染树**，浏览器检查每个节点，从DOM树的根节点开始，决定哪些CSS规则被添加

**渲染树只包含可见内容**

### 4.4.JS编译

脚本会被解析成抽象语法树



## 5.渲染

最后一步是将像素绘制在屏幕，之后，只有受影响的屏幕区域会被重绘，浏览器被优化为只重绘需要绘制的最小区域

### 5.1.样式

关键呈现路径的第三步是将 DOM 和 CSSOM 组合成渲染树。计算样式树或渲染树的构建从 DOM 树的根开始，遍历每个可见节点。

每个可见节点都应用了 CSSOM 规则。渲染树包含所有可见节点的内容和计算样式，将所有相关样式与 DOM 树中的每个可见节点匹配起来，并根据 [CSS 级联](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade)，确定每个节点的计算样式。

CSS权重 == 自定义 > 默认 > 继承



### 5.2.布局

第四步是在渲染树上运行布局以计算每个节点的几何体。*布局*是确定呈现树中所有节点的尺寸和位置，以及确定页面上每个对象的大小和位置的过程。*重排*是后续过程中对页面的任意部分或整个文档的大小和位置的重新计算。

渲染树构建完毕后，浏览器就开始布局。渲染树标识了哪些节点会显示（即使不可见）及其计算样式，但不标识每个节点的尺寸或位置。为了确定每个对象的确切大小和位置，浏览器会从渲染树的根开始遍历。







# CSS动画和JS动画的性能

后台运行时，动画会暂停 

大多数场景下，基于CSS的动画几乎和JS动画表现一致

GSAP和Velocity.JS（JS动画库）

## 1.CSS中的transition 和 animation

## 2.JS的requestAnimationFrame

本方法的回调函数在绘制下一帧之前由浏览器调用，





# 懒加载 == 延迟加载

常规

* 入口点分离代码
* 动态import分离代码

















