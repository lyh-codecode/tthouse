# 排序算法

## 1.交换排序

### 冒泡排序

重复地遍历待排序元素，比较相邻两个元素，如果逆序则交换位置,遍历n - 1 次

每次遍历结束，无序序列的最大元素就会排到最后，所以每次遍历的范围是 j < n - i - 1



优化： 可以加入一个标记，每次遍历的时候等于0，发生交换变为1，如果没发生交换直接break

说明已经有序，提前结束排序



### 快速排序

数组分区，递归

* 选择一个元素作为基准，最后一个或者第一个 p
* 左边标记向右移动，达到值超过p的停下
* 右边标记向左移动，达到值小于p的停下
* 然后两个交换，之后继续移动，当左边和右边相遇的时候停下
* 如果左右标记在同一位置，将这个数字和p交换
* 然后递归实现

```c
void quickSort(int arr[],int low,int high) {
	int i = low;
    int j = high;
    if(i >= j) {
		return;
    }
    
    int temp = array[low];
    while( i!=j ) {
		while(array[j] >= temp && i < j) {
			j--;
        }
        while(array[j] <= temp && i < j) {
			i++;
        }
        if(i < j) {
            swap(array[i],array[j]);
        }
    }
    
    swap(array[low],array[i]);
    quickSort(array,low,i - 1);
    quickSort(array,i + 1,high);
}
```







## 2.选择排序

### 简单选择排序

遍历数组，选择最小的元素，和当前未排序部分的第一个元素进行交换

每次遍历的时候设置最小索引为i，一直这样操作



最外层遍历n-1次，因为n个元素只需要选择比较n-1次

内层循环遍历n-i次



### 堆排序

基于完全二叉树的选择排序，

堆化后得到根节点（当前序列最大值），和最后一个元素交换

减小排序序列长度，重新堆化，和当前最后一个元素交换



## 3.插入排序

### 直接插入排序

有序区域 1--i，判断要插入的值是否在有序区间内

使用第一个单元保存插入值，使用while循环寻找插入位置



最好的情况下，时间复杂度为 O(n)，最差为O(n^2)

只需要一个辅助记录的空间，空间复杂度为O(1)



### 希尔排序（缩小增量排序）

规定一个增量，第i个元素和第i+d个元素比较，逆序就交换位置

不断减少增量，直到d=1，变成直接插入排序





## 4.归并排序

是不断将两个或两个以上有序区合并成

一个有序区，直到全部记录有序





## 5.基数排序

不需要进行记录关键字的比较

